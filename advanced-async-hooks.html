<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title># Advanced asynchronous hooks:</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Aerospike-clj</span> <span class="project-version">2.0.8-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="advanced-async-hooks.html"><div class="inner"><span># Advanced asynchronous hooks:</span></div></a></li><li class="depth-1 "><a href="tutorial.html"><div class="inner"><span>Tutorial</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aerospike-clj</span></div></div></li><li class="depth-2 branch"><a href="aerospike-clj.aerospike-record.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aerospike-record</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.bins.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bins</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.client.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>client</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.key.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>key</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.listeners.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>listeners</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.metrics.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>metrics</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.mock-client.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mock-client</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.policy.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>policy</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-2"><a href="aerospike-clj.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h2><a href="#advanced-asynchronous-hooks" id="advanced-asynchronous-hooks"></a>Advanced asynchronous hooks:</h2>
<p>Since <code>aerospike-clj</code> uses a future based model instead of a callback based model, it is convenient to compose complex asynchronous logic using <a href="https://github.com/funcool/promesa">promesa</a>.</p>
<p>By implementing the <code>ClientEvents</code> protocol 2 hooks are exposed that are called for each API call: <code>on-success</code> and <code>on-failure</code>.</p>
<p>Those hooks are called with valuable information that can be used, for example to configure automatic logging or metrics on your client. Here is an example of such code that is reporting useful metrics to <a href="https://github.com/etsy/statsd">statsd</a>. So assuming you have some <code>statsd</code> namespace tha can connect and report to a <code>statsd</code> server, and some <code>metrics</code> namespace that is used to properly format the metric names:</p>
<pre><code class="language-clojure">(ns af-common-rta-aerospike.core
  (:require [aerospike-clj.protocols :as pt]
            [statsd.metrics :as metrics]
            [statsd.core :as statsd]
            [promesa.core :as p]))

(defrecord DBMeter [cluster-name]
  pt/ClientEvents
  (on-success [_ op-name op-result _index op-start-time]
    (statsd/send-timing (metrics/format-statsd-metric cluster-name op-name "latency")
                        (micros-from op-start-time)
                        STATSD-RATE)
    (statsd/inc-metric (metrics/format-statsd-metric cluster-name op-name "success"))
    (when (= "read" op-name)
      (if (some? op-result)
         (statsd/inc-metric (metrics/format-statsd-metric cluster-name "read" "hit"))
         (statsd/inc-metric (metrics/format-statsd-metric cluster-name "read" "miss"))))
    op-result)
  (on-failure [_ op-name op-ex index op-start-time]
    (statsd/send-timing (metrics/format-statsd-metric cluster-name op-name "latency")
                        (micros-from op-start-time)
                        STATSD-RATE)
    (statsd/inc-metric (metrics/format-statsd-metric-fail-aerospike op-ex (:cluster-name client) op-name))
    (p/rejected! op-ex)))
</code></pre>
<p>A few notes on the above code: 1. Passed arguments: * <code>op-name</code>, <code>op-result</code> and <code>index</code> are strings. They are partially used for metrics generation in our case. * <code>op-start-time</code> is <code>(System/nanoTime)</code>, converted here to microseconds and used to measure latency. 2. The code is using the passed arguments to measure latency and format metrics’ names. You can easily do other stuff like logging, etc. 3. Both <code>on-success</code> and <code>on-failure</code> return the results passed in. Although this logic is the last logic that happens to the operations’ results (e.g. after transcoders are called), the returned result will be what the calling code gets as a returned value.</p>
<p>Finally, hook it to your client:</p>
<pre><code class="language-clojure">user=&gt; (def c (aero/init-simple-aerospike-client ["localhost"] "test" {:client-events (-&gt;DBMeter "test-cluster")}))
</code></pre>
</div></div></div></body></html>