<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Tutorial</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Aerospike-clj</span> <span class="project-version">2.0.8-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="advanced-async-hooks.html"><div class="inner"><span># Advanced asynchronous hooks:</span></div></a></li><li class="depth-1  current"><a href="tutorial.html"><div class="inner"><span>Tutorial</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aerospike-clj</span></div></div></li><li class="depth-2 branch"><a href="aerospike-clj.aerospike-record.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aerospike-record</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.bins.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bins</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.client.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>client</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.key.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>key</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.listeners.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>listeners</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.metrics.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>metrics</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.mock-client.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mock-client</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.policy.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>policy</span></div></a></li><li class="depth-2 branch"><a href="aerospike-clj.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-2"><a href="aerospike-clj.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#tutorial" id="tutorial"></a>Tutorial</h1>
<h2><a href="#general" id="general"></a>General</h2>
<h3><a href="#what-is-this-library" id="what-is-this-library"></a>What is this library?</h3>
<p>This library is a Clojure wrapper over the <a href="https://www.aerospike.com/docs/client/java/">Aerospike Java library</a>. The Java Documentation can be found <a href="https://www.aerospike.com/apidocs/java/">here</a>.</p>
<p>For a complete reference of Aerospike Java client internals I warmly recommend reading the <a href="https://github.com/aerospike/aerospike-client-java/tree/master/examples">Java client examples</a>.</p>
<p>This library wraps the Java code, hides all Clojure Java interop and supplies a more functional approach to Aerospike. It also adds a few handy features.</p>
<p>A note worth mentioning at the beginning is that the Java client has both synchronous and asynchronous APIs. This library however, only wraps the asynchronous ones. If a synchronous behaviour is still desired, it can be be easily achieved, as shown below.</p>
<p>Also, although possible to combine several namespaces in a single cluster, this library uses a single client object per cluster/client.</p>
<h3><a href="#setup" id="setup"></a>Setup</h3>
<h4><a href="#docker" id="docker"></a>Docker</h4>
<p>For this tutorial we will take advantage of a locally deployed Aerospike DB with docker container. The following command should download and install a docker image with the latest Aerospike image on your machine.</p>
<pre><code class="language-bash">$ sudo docker run -d --name aerospike -p 3000:3000 -p 3001:3001 -p 3002:3002 -p 3003:3003 aerospike"
</code></pre>
<p>The DB created contains a single namespace named <code>test</code>. On production, Aerospike is a distributed cluster composed of several nodes.</p>
<h4><a href="#repl" id="repl"></a>REPL</h4>
<p>In order to follow the example further in this tutorial, you should run a Clojure REPL with the library located in the classpath. This can be done: - by cloning the library and running a REPL:</p>
<pre><code class="language-bash">$ git clone https://github.com/AppsFlyer/aerospike-clj.git
$ cd aerospike-clj
$ lein repl
</code></pre>
<ul>
<li>-or- using <a href="https://github.com/avescodes/lein-try">lein-try</a>:</li>
</ul>
<pre><code class="language-bash">$ lein try aerospike-clj "0.2.1"
...
user=&gt; (require '[aerospike-clj.client :as aero])
nil
</code></pre>
<ul>
<li>-or- by referencing it in your project <code>profiles.clj</code> and running a repl there:</li>
</ul>
<pre><code class="language-clojure">(defproject af-common-rta-aerospike "3.0.0"
  :dependencies [[aerospike-clj "2.0.0"]]
  ; ...
  )
</code></pre>
<h2><a href="#usage" id="usage"></a>Usage</h2>
<h4><a href="#client-creation" id="client-creation"></a>Client creation</h4>
<p>First, let’s create a client:</p>
<pre><code class="language-clojure">user=&gt; (require '[aerospike-clj.client :as aero])
nil
user=&gt; (def c (aero/init-simple-aerospike-client ["localhost"] "test"))
;; Starting aerospike clients for clusters localhost with username null
#'user/c
user=&gt;
</code></pre>
<p>That’s it. A client creation requires only a vector of servers to bootstrap from and a namespace name. Behind the scenes the client constructor is called with a default <a href="https://www.aerospike.com/apidocs/java/com/aerospike/client/policy/ClientPolicy.html"><code>ClientPolicy</code></a>. In order to further configure the client for your needs pass a configuration map as the last argument. The map is a flat map of string keys, corresponding to the <code>ClientPolicy</code> class. To use the Java enumerations, simply uppercase the first character:</p>
<pre><code class="language-clojure">user=&gt; (def c (aero/init-simple-aerospike-client ["localhost"]
                                                 "test"
                                                 {"failIfNotConnected" true
                                                  "AuthMode" "INTERNAL"
                                                  "username" nil
                                                  "password" nil
                                                  "maxCommandsInProcess" 0}))
;; Starting aerospike clients for clusters localhost with username null
#'user/c
</code></pre>
<p>Currently, almost all configuration (except default batch/info/query/scan policies) can be passed to <code>init-simple-aerospike-client</code> in the <code>conf</code> map. This includes <code>ClientPolicy</code> and <code>EventPolicy</code> configurations, flattened together (e.g <code>maxCommandsInProcess</code>) :</p>
<p>The Java client can cache all API related policies for you, and then uses them when a <code>nil</code> policy is passed to the API call. This is worthwhile because most of the time, the same policies are used throughout the application lifetime. Those caches are initiated with the (mostly sane) defaults. You can change them by creating custom ones:</p>
<pre><code class="language-clojure">user=&gt; (require '[aerospike-clj.policy :as policy])
nil
user=&gt; (def new-wp (policy/map-&gt;write-policy {"CommitLevel" "COMMIT_MASTER" "sendKey" true}))
#'user/new-wp
user=&gt; (.commitLevel new-wp)
Reflection warning...
#object[com.aerospike.client.policy.CommitLevel 0x2f1f3fef "COMMIT_MASTER"]
user=&gt; (.sendKey new-wp)
Reflection warning...
true
</code></pre>
<h5><a href="#important-note" id="important-note"></a>Important note:</h5>
<p>The functions <code>map-&gt;policy</code> and <code>map-&gt;write-policy</code> are slow due to reflection and are here to save you some Java interop. Since they are slow, <strong>do not</strong> use them to create one-time-use policies for each API call. Use them just to tweak the defaults:</p>
<pre><code class="language-clojure">user=&gt; (def c (aero/init-simple-aerospike-client ["localhost"] "test" {"writePolicyDefault" new-wp}))
#'user/c
user=&gt; (.commitLevel (.writePolicyDefault (aero/get-client c)))
#object[com.aerospike.client.policy.CommitLevel 0x2f1f3fef "COMMIT_MASTER"]
</code></pre>
<p>Those <code>AerospikeClient</code> fields are <code>final</code> hence can only be set on client creation, but you can also have a few useful policies <code>def</code>ed somewhere and pass them later under the <code>:policy</code> key of the API calls.</p>
<h4><a href="#querying" id="querying"></a>Querying</h4>
<p>Querying is only possible (read: easy) via the asynchronous APIs of the client. <code>aerospike-clj</code> also converts the callback model of the underlying APIs to a future based model (using <a href="https://github.com/funcool/promesa"><code>promesa</code></a>). This allows users to configure additional logic to happen when the response returns. But first, let’s see a simple query:</p>
<pre><code class="language-clojure">user=&gt; (require '[aerospike-clj.protocols :as pt])
nil
user=&gt; (def f (pt/get-single c "not-there" "set-name"))
user=&gt; (type f)
java.util.concurrent.CompletableFuture
user=&gt; (deref f)
nil
</code></pre>
<p>Joy! We got a future answer. In this case, the deferred result is <code>nil</code>, since the key <code>"not-there"</code> is missing. Futures can be composed with logic that happens once they are delivered (for a complete documentation, see <code>promesa</code>’s docs <a href="https://funcool.github.io/promesa/latest/">here</a>. Behold:</p>
<pre><code class="language-clojure">user=&gt; (require '[promesa.core :as p])
nil
user=&gt; (p/then (pt/get-single c "index" "set-name")
  #_=&gt;         #(if %1 (prn "good!") (prn "not there")))
"not there"
</code></pre>
<p>If the record existed we would get an <code>AerospikeRecord</code>:</p>
<pre><code class="language-clojure">user=&gt; (pt/put c "index" "set-name" 42 1000)
#object[java.util.concurrent.CompletableFuture 0x16283d4b "pending"]
user=&gt; (def f (pt/get-single c "index" "set-name"))
#'user/f
user=&gt; (deref f)
#aerospike_clj.client.AerospikeRecord{:payload 42, :gen 1, :ttl 284805805}
user=&gt;
</code></pre>
<p>We observe a few new things: 1. The <code>put</code> API also returns futures. Those will contain the operation’s result when it completes. 2. The <code>put</code> API requires an additional argument, the TTL. Although Aerospike cluster namespaces have a default TTL, and there is also a default TTL in the Java client, we chose to make your life harder here. This is because we believe that TTLs are too important to be default, and programmers must think about them. 3. In the query result we got a Clojure record with a triplet: <code>:payload</code> with the value, <code>:gen</code> for the record generation, and a <code>:ttl</code> for the record TTL, in Aerospike format. This resembles the <a href="https://www.aerospike.com/apidocs/java/com/aerospike/client/Record.html">Record class</a>. In order to convert the TTL to Unix epoch you can call <code>expiry-unix</code> on it (see below).</p>
<h4><a href="#unix-epoch-ttl" id="unix-epoch-ttl"></a>Unix epoch TTL</h4>
<p>Aerospike returns a TTL on the queried records that is Epoch style, but with a different “beginning of time” which is “2010-01-01T00:00:00Z”. Call <code>expiry-unix</code> with the returned TTL to get a TTL reative to UNIX epoch if you want to convert it later to a more standard timestamp.</p>
<pre><code class="language-clojure">user=&gt; (-&gt; f
  #_=&gt;     deref
  #_=&gt;     :ttl
  #_=&gt;     aero/expiry-unix
  #_=&gt;     java.time.Instant/ofEpochSecond
  #_=&gt;     str)
"2019-01-10T08:43:25Z"
</code></pre>
<p>Let’s do it in an asynchronous manner:</p>
<pre><code class="language-clojure">user=&gt; (p/chain (pt/get-single c "index" "set-name")
  #_=&gt;          :ttl
  #_=&gt;          aero/expiry-unix
  #_=&gt;          #(java.time.Instant/ofEpochSecond %)
  #_=&gt;          str
  #_=&gt;          println)
#object[java.util.concurrent.CompletableFuture 0x4a9620a9 "pending"]
2019-01-10T09:02:45Z
</code></pre>
<p>We got a deferred back and some time later the whole chain of composed logic was triggered. We can also get the result once multiple required records return. We will simply get a sequence of <code>AerospikeRecord</code>s once all of them arrive:</p>
<pre><code class="language-clojure">user=&gt; (run! #(pt/put c (str %1) "set-name" %1 1000) (range 5))
nil
user=&gt; @(p/then (aero/get-multiple c (map str (range 5)) (repeat "set-name"))
  #_=&gt;          #(map :payload %))
(0 1 2 3 4)
</code></pre>
<h5><a href="#sync-querying" id="sync-querying"></a>Sync Querying</h5>
<p>Since the returned future objects can be easily <code>deref</code>ed, simply adding a <code>@</code> before queries makes them synchronous.</p>
<h4><a href="#using-transcoders" id="using-transcoders"></a>Using Transcoders</h4>
<p>The library takes advantage of futures’ ability to compose and allows you to configure a <code>:transcoder</code> to conveniently set this logic: * <code>get</code> Transcoders are functions of the <strong>AerospikeRecord instance</strong>, not the <code>deferred</code> value of it. * <code>put</code> Transcoders are functions on the passed <strong>payload</strong>. They are called <em>before</em> the request is even put on the event-loop.</p>
<h5><a href="#on-get" id="on-get"></a>On get:</h5>
<pre><code class="language-clojure">user=&gt; (pt/put c "index" "set-name" 42 1000)
#object[java.util.concurrent.CompletableFuture 0x4a9620a9 "pending"]
user=&gt; (defn inc-transcoder [rec] (when rec
  #_=&gt;                                  (update rec :payload inc)))
#'user/inc-transcoder
user=&gt; (p/chain (pt/get-single c "index" "set-name" {:transcoder inc-transcoder})
  #_=&gt;          :payload
  #_=&gt;          println)
#object[java.util.concurrent.CompletableFuture 0x4a9620af "pending"]
43
</code></pre>
<h5><a href="#on-put" id="on-put"></a>On put:</h5>
<p>The transcoder here is a function on the <em>payload</em> itself</p>
<pre><code class="language-clojure">user=&gt; (pt/put c "17" "set-name" 1 1000 {:transcoder str})
#object[java.util.concurrent.CompletableFuture 0x4d025d9b "pending"]
user=&gt; @(pt/get-single c "17" "set-name" {:transcoder #(:payload %1)})
"1"
</code></pre>
<p>The transcoder option saves some boilerplate and can be easily used to do more useful stuff, like de-serializing or (de)compressing data on the client side.</p>
</div></div></div></body></html>